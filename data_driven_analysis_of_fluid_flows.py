# -*- coding: utf-8 -*-
"""Data_Driven_Analysis_Of_Fluid_Flows.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1wPDoOzBD5QLMDzrjL5o3xzoOrODbLOuC

##Importing Dataset
"""

!pip install opencv-python-headless

from google.colab import drive
import cv2
import pandas as pd
import matplotlib.pyplot as plt
import numpy as np
import tensorflow as tf
from tensorflow.keras import layers, models
from skimage.metrics import peak_signal_noise_ratio as psnr
from skimage.metrics import structural_similarity as ssim

drive.mount('/content/drive')

#/content/drive/MyDrive/B22ME054/Copy of 3CYL_Flow.mp4
#/content/drive/MyDrive/3CYL_Flow.mp4
video_capture = cv2.VideoCapture('/content/drive/MyDrive/B22ME054/Copy of 3CYL_Flow.mp4')

"""##.MP4 to Pandas dataset"""

frames_data = []

# Check if the video file is opened successfully
if not video_capture.isOpened():
    print("Error: Could not open the video file.")
else:
    # Read frames from the video file, first 275 frames
    frame_count = 0
    while (frame_count<275):
        ret, frame = video_capture.read()

        # If there are no more frames to read, break the loop
        if not ret:
            break

        # Resize the frame
        resized_frame = cv2.resize(frame, (825, 375))

        # Crop the resized frame from the left side
        cropped_frame = resized_frame[:, 120:]

        # Convert frame to grayscale
        frame_gray = cv2.cvtColor(cropped_frame, cv2.COLOR_BGR2GRAY)

        # Store frame data in a dictionary
        frame_info = {
            'Frame': frame_count,
            'Frame_data': frame_gray
        }
        frames_data.append(frame_info)

        frame_count += 1

# Convert the list of dictionaries to a pandas DataFrame
frames_df = pd.DataFrame(frames_data)

print(frames_df.head())

print (frame_count)

frames_df['Frame_data'][3][285][280]

frames_df['Frame_data'].shape

frames_df['Frame_data'][1].shape

def display_images(df):
    for index, row in df.iterrows():
        frame = row['Frame_data']
        plt.imshow(frame)
        plt.axis('off')
        plt.show()

display_images(frames_df.head(5))

"""## Reduced SVD on dataset"""

flattened_frames = [frame.flatten() for frame in frames_df['Frame_data']]

# Stack flattened frames into a matrix
data_matrix = np.stack(flattened_frames, axis=0)

# Compute the mean of the data matrix
mean_frame = np.mean(data_matrix, axis=0)

frame = mean_frame.reshape(375, 705)
plt.imshow(frame)
plt.axis('off')
plt.show()

# Subtract the mean from each frame
data_matrix_centered = data_matrix - mean_frame

normalized_data_matrix = data_matrix_centered / np.linalg.norm(data_matrix_centered)

# Apply rSVD
k = 30  # Number of singular vectors and values to retain
U, Sigma, VT = np.linalg.svd(normalized_data_matrix, full_matrices=False)
Ur = U[:, :k]
Sigmak = np.diag(Sigma[:k])
VTr = VT[:k, :]

pod_modes_svd = VTr[:k, :].T

print(U.shape)
print(Sigma.shape)
print(VT.shape)
print(pod_modes_svd.shape)

print(Ur.shape)
print(Sigmak.shape)
print(VTr.shape)
print(pod_modes_svd.shape)

Sigmak_diag = np.diag(Sigmak)

# Compute the energy content of each mode
energy_content = Sigmak_diag**2

# Total energy captured by all modes
total_energy = np.sum(energy_content)

# Normalize energy content
normalized_energy_content = energy_content / total_energy

# Assuming energy_content contains the energy content of each mode
top_10_modes_indices = np.argsort(normalized_energy_content)[::-1][:10]

# Print energy of the top 10 modes
print("Energy of the top 10 modes:")
for mode_index in top_10_modes_indices:
    print(f"Mode {mode_index + 1}: Energy = {normalized_energy_content[mode_index]}")

# Plot histogram of energy content vs mode
plt.figure(figsize=(12, 6))
plt.bar(range(1, len(normalized_energy_content) + 1), normalized_energy_content, color='skyblue', edgecolor='black')
plt.title('Energy vs Mode')
plt.xlabel('Mode')
plt.ylabel('Energy')
plt.grid(axis='y')
plt.show()

largest_energy_mode_index = np.argmax(energy_content)
largest_energy_mode = Ur[:, largest_energy_mode_index]

# Print or use the largest energy mode as needed
print("Mode with the largest energy:")
print(largest_energy_mode)

pod_modes_svd_transpose = np.transpose(pod_modes_svd)

# Function to display POD mode as an image
def display_pod_mode(mode, index):
    # Reshape the mode to the shape of the original image
    mode_image = mode.reshape(375, 705)

    # Convert to 8-bit depth
    mode_image_8bit = cv2.normalize(mode_image, None, 0, 255, cv2.NORM_MINMAX, dtype=cv2.CV_8U)

    # Plot the mode
    plt.imshow(mode_image_8bit)
    plt.title(f'POD Mode {index+1}')
    plt.axis('off')
    plt.show()

# Display the POD modes as 8-bit depth images
for (i), mode in enumerate(pod_modes_svd_transpose):
    display_pod_mode(mode, i)
    if(i==5):
      break

"""## Adding Noise"""

def add_gaussian_noise(image, percent_of_max=20):

    noisy_image = np.copy(image)

    max_magnitude = np.max(noisy_image)
    noise_magnitude = (percent_of_max / 100) * max_magnitude

    gaussian_noise = np.random.normal(0, noise_magnitude, noisy_image.shape)

    noisy_image += gaussian_noise.astype(np.uint8)
    noisy_image = np.clip(noisy_image, 0, 255)

    return noisy_image

def add_salt_and_pepper_noise(image, percent_of_max=20):

    noisy_image = np.copy(image)

    max_magnitude = np.max(noisy_image)
    noise_magnitude = (percent_of_max / 100) * max_magnitude

    salt_noise_mask = np.random.rand(*noisy_image.shape) < (0.5 * percent_of_max / 100)
    pepper_noise_mask = np.random.rand(*noisy_image.shape) < (0.5 * percent_of_max / 100)

    noisy_image[salt_noise_mask] = 255
    noisy_image[pepper_noise_mask] = 0

    return noisy_image

# Add noise to original frames
noisy_frames_gaussian_20 = [add_gaussian_noise(frame, percent_of_max=20) for frame in frames_df['Frame_data']]
noisy_frames_gaussian_40 = [add_gaussian_noise(frame, percent_of_max=40) for frame in frames_df['Frame_data']]
noisy_frames_gaussian_60 = [add_gaussian_noise(frame, percent_of_max=60) for frame in frames_df['Frame_data']]
noisy_frames_gaussian_80 = [add_gaussian_noise(frame, percent_of_max=80) for frame in frames_df['Frame_data']]

noisy_frames_salt_pepper_20 = [add_salt_and_pepper_noise(frame, percent_of_max=20) for frame in frames_df['Frame_data']]
noisy_frames_salt_pepper_40 = [add_salt_and_pepper_noise(frame, percent_of_max=40) for frame in frames_df['Frame_data']]
noisy_frames_salt_pepper_60 = [add_salt_and_pepper_noise(frame, percent_of_max=60) for frame in frames_df['Frame_data']]
noisy_frames_salt_pepper_80 = [add_salt_and_pepper_noise(frame, percent_of_max=80) for frame in frames_df['Frame_data']]

# Original frame
plt.imshow(frames_df['Frame_data'][100])
plt.title('Original Frame')
plt.axis('off')

# Example: Display original and noisy frames
plt.figure(figsize=(14, 20))

plt.subplot(4, 2, 1)
plt.imshow(noisy_frames_gaussian_20[100])
plt.title('Gaussian 20%')
plt.axis('off')

plt.subplot(4, 2, 2)
plt.imshow(noisy_frames_salt_pepper_20[100])
plt.title('Salt&Pepper 20%')
plt.axis('off')

plt.subplot(4, 2, 3)
plt.imshow(noisy_frames_gaussian_40[100])
plt.title('Gaussian 40%')
plt.axis('off')

plt.subplot(4, 2, 4)
plt.imshow(noisy_frames_salt_pepper_40[100])
plt.title('Salt&Pepper 40%')
plt.axis('off')

plt.subplot(4, 2, 5)
plt.imshow(noisy_frames_gaussian_60[100])
plt.title('Gaussian 60%')
plt.axis('off')

plt.subplot(4, 2, 6)
plt.imshow(noisy_frames_salt_pepper_60[100])
plt.title('Salt&Pepper 60%')
plt.axis('off')

plt.subplot(4, 2, 7)
plt.imshow(noisy_frames_gaussian_80[100])
plt.title('Gaussian 80%')
plt.axis('off')

plt.subplot(4, 2, 8)
plt.imshow(noisy_frames_salt_pepper_80[100])
plt.title('Salt&Pepper 80%')
plt.axis('off')

plt.tight_layout()
plt.show()

"""###Gaussian Noise on 20%"""

flattened_frames_gauss = [frame.flatten() for frame in noisy_frames_gaussian_20]

# Stack flattened frames into a matrix
data_matrix_gauss = np.stack(flattened_frames_gauss, axis=0)

# Compute the mean of the data matrix
mean_frame_gauss = np.mean(data_matrix_gauss, axis=0)

frame_gauss = mean_frame_gauss.reshape(375, 705)

plt.imshow(frame_gauss)
plt.axis('off')
plt.show()

# Subtract the mean from each frame
data_matrix_centered_gauss = data_matrix_gauss - mean_frame_gauss

normalized_data_matrix_gauss = data_matrix_centered_gauss / np.linalg.norm(data_matrix_centered_gauss)

normalized_data_matrix_gauss.shape

# Apply rSVD
k = 30  # Number of singular vectors and values to retain
U_gauss, Sigma_gauss, VT_gauss = np.linalg.svd(normalized_data_matrix_gauss, full_matrices=False)
Ur_gauss = U_gauss[:, :k]
Sigmak_gauss = np.diag(Sigma_gauss[:k])
VTr_gauss = VT_gauss[:k, :]

pod_modes_svd_gauss = VTr_gauss[:k, :].T

print(U_gauss.shape)
print(Sigma_gauss.shape)
print(VT_gauss.shape)
print(pod_modes_svd_gauss.shape)

print(Ur_gauss.shape)
print(Sigmak_gauss.shape)
print(VTr_gauss.shape)
print(pod_modes_svd_gauss.shape)

Sigmak_diag_gauss = np.diag(Sigmak_gauss)

# Compute the energy content of each mode
energy_content_gauss = Sigmak_diag_gauss**2

# Total energy captured by all modes
total_energy_gauss = np.sum(energy_content_gauss)

# Normalize energy content
normalized_energy_content_gauss = energy_content_gauss / total_energy_gauss


# Assuming energy_content contains the energy content of each mode
top_10_modes_indices_gauss = np.argsort(energy_content_gauss)[::-1][:10]

# Print energy of the top 10 modes
print("Energy of the top 10 modes:")
for mode_index in top_10_modes_indices_gauss:
    print(f"Mode {mode_index + 1}: Energy = {normalized_energy_content_gauss[mode_index]}")

# Plot histogram of energy content vs mode
plt.figure(figsize=(12, 6))
plt.bar(range(1, len(normalized_energy_content_gauss) + 1), normalized_energy_content_gauss, color='skyblue', edgecolor='black')
plt.title('Energy vs Mode')
plt.xlabel('Mode')
plt.ylabel('Energy')
plt.grid(axis='y')
plt.show()

largest_energy_mode_index_gauss = np.argmax(energy_content_gauss)
largest_energy_mode_gauss = Ur_gauss[:, largest_energy_mode_index_gauss]

# Print or use the largest energy mode as needed
print("Mode with the largest energy:")
print(largest_energy_mode_gauss)

pod_modes_svd_transpose_gauss= np.transpose(pod_modes_svd_gauss)

# Function to display POD mode as an image
def display_pod_mode(mode, index):
    # Reshape the mode to the shape of the original image
    mode_image = mode.reshape(375, 705)

    # Convert to 8-bit depth
    mode_image_8bit = cv2.normalize(mode_image, None, 0, 255, cv2.NORM_MINMAX, dtype=cv2.CV_8U)

    # Plot the mode
    plt.imshow(mode_image_8bit)
    plt.title(f'POD Mode {index+1}')
    plt.axis('off')
    plt.show()

# Display the POD modes as 8-bit depth images
for (i), mode in enumerate(pod_modes_svd_transpose_gauss):
    display_pod_mode(mode, i)
    if(i==5):
      break

"""###Salt & Pepper Noise on 20%"""

flattened_frames_sp = [frame.flatten() for frame in noisy_frames_salt_pepper_20]

# Stack flattened frames into a matrix
data_matrix_sp = np.stack(flattened_frames_sp, axis=0)

# Compute the mean of the data matrix
mean_frame_sp = np.mean(data_matrix_sp, axis=0)

frame_sp = mean_frame_sp.reshape(375, 705)

plt.imshow(frame_sp)
plt.axis('off')
plt.show()

# Subtract the mean from each frame
data_matrix_centered_sp = data_matrix_sp - mean_frame_sp

normalized_data_matrix_sp = data_matrix_centered_sp / np.linalg.norm(data_matrix_centered_sp)

# Apply rSVD
k = 30  # Number of singular vectors and values to retain
U_sp, Sigma_sp, VT_sp = np.linalg.svd(normalized_data_matrix_sp, full_matrices=False)
Ur_sp = U_sp[:, :k]
Sigmak_sp = np.diag(Sigma_sp[:k])
VTr_sp = VT_sp[:k, :]

pod_modes_svd_sp = VTr_sp[:k, :].T

print(U_sp.shape)
print(Sigma_sp.shape)
print(VT_sp.shape)
print(pod_modes_svd_sp.shape)

print(Ur_sp.shape)
print(Sigmak_sp.shape)
print(VTr_sp.shape)
print(pod_modes_svd_sp.shape)

Sigmak_diag_sp = np.diag(Sigmak_sp)

# Compute the energy content of each mode
energy_content_sp = Sigmak_diag_sp**2

# Total energy captured by all modes
total_energy_sp = np.sum(energy_content_sp)

# Normalize energy content
normalized_energy_content_sp = energy_content_sp / total_energy_sp


# Assuming energy_content contains the energy content of each mode
top_10_modes_indices_sp = np.argsort(energy_content_sp)[::-1][:10]

# Print energy of the top 10 modes
print("Energy of the top 10 modes:")
for mode_index in top_10_modes_indices_sp:
    print(f"Mode {mode_index + 1}: Energy = {normalized_energy_content_sp[mode_index]}")

# Plot histogram of energy content vs mode
plt.figure(figsize=(12, 6))
plt.bar(range(1, len(normalized_energy_content_sp) + 1), normalized_energy_content_sp, color='skyblue', edgecolor='black')
plt.title('Energy vs Mode')
plt.xlabel('Mode')
plt.ylabel('Energy')
plt.grid(axis='y')
plt.show()

largest_energy_mode_index_sp = np.argmax(energy_content_sp)
largest_energy_mode_sp = Ur_sp[:, largest_energy_mode_index_sp]

# Print or use the largest energy mode as needed
print("Mode with the largest energy:")
print(largest_energy_mode_sp)

pod_modes_svd_transpose_sp= np.transpose(pod_modes_svd_sp)

# Function to display POD mode as an image
def display_pod_mode(mode, index):
    # Reshape the mode to the shape of the original image
    mode_image = mode.reshape(375, 705)

    # Convert to 8-bit depth
    mode_image_8bit = cv2.normalize(mode_image, None, 0, 255, cv2.NORM_MINMAX, dtype=cv2.CV_8U)

    # Plot the mode
    plt.imshow(mode_image_8bit)
    plt.title(f'POD Mode {index+1}')
    plt.axis('off')
    plt.show()

# Display the POD modes as 8-bit depth images
for (i), mode in enumerate(pod_modes_svd_transpose_sp):
    display_pod_mode(mode, i)
    if(i==5):
      break

"""##Super-Resolving

### Gaussian Noise on 20%
"""

def denoise_frame(frame, prev_frame=None, median_kernel_size=3, gaussian_kernel_size=(5, 5), bilateral_diameter=7, bilateral_sigma_color=50, bilateral_sigma_space=50):

    # Apply Median Filtering
    denoised_frame = cv2.medianBlur(frame, median_kernel_size)

    # Apply Gaussian Filtering
    denoised_frame = cv2.GaussianBlur(denoised_frame, gaussian_kernel_size, 0)

    # Apply Bilateral Filtering
    denoised_frame = cv2.bilateralFilter(denoised_frame, bilateral_diameter, bilateral_sigma_color, bilateral_sigma_space)

    # Apply Temporal Filtering
    if prev_frame is not None:
        # Perform temporal averaging
        denoised_frame = cv2.addWeighted(denoised_frame, 0.5, prev_frame, 0.5, 0)
        # Update previous frame for next iteration
        updated_prev_frame = frame.copy()
    else:
        updated_prev_frame = frame.copy()

    return denoised_frame, updated_prev_frame



denoised_frames_gauss = []
updated_prev_frame_gauss = None
for frame in noisy_frames_gaussian_20:
    denoised_frame_gauss, updated_prev_frame_gauss = denoise_frame(frame, prev_frame=updated_prev_frame_gauss)
    denoised_frames_gauss.append(denoised_frame_gauss)

plt.figure(figsize=(10, 10))

# Original frame
plt.subplot(2, 1, 1)
plt.imshow(denoised_frames_gauss[100])
plt.title('Noisy Frame (Gaussian) denoised')
plt.axis('off')

# Noisy frame with Gaussian noise
plt.subplot(2, 1, 2)
plt.imshow(noisy_frames_gaussian_20[100])
plt.title('Noisy Frame (Gaussian)')
plt.axis('off')

psnr_values_gauss = []
ssim_values_gauss = []

def evaluate_frame(original_frame, denoised_frame):
    # Calculate PSNR
    psnr_value = psnr(original_frame, denoised_frame)
    # Calculate SSIM
    ssim_value = ssim(original_frame, denoised_frame)
    return psnr_value, ssim_value

for original_frame, denoised_frame in zip(frames_df['Frame_data'], denoised_frames_gauss):
    # Calculate PSNR and SSIM for the current frame pair
    psnr_value, ssim_value = evaluate_frame(original_frame, denoised_frame)

    # Append PSNR and SSIM values to the lists
    psnr_values_gauss.append(psnr_value)
    ssim_values_gauss.append(ssim_value)

average_psnr_gauss = sum(psnr_values_gauss) / len(psnr_values_gauss)
average_ssim_gauss = sum(ssim_values_gauss) / len(ssim_values_gauss)

print("Average PSNR:", average_psnr_gauss)
print("Average SSIM:", average_ssim_gauss)

"""#### Applying SVD"""

flattened_frames_di_gauss = [frame.flatten() for frame in denoised_frames_gauss]

# Stack flattened frames into a matrix
data_matrix_di_gauss = np.stack(flattened_frames_di_gauss, axis=0)

# Compute the mean of the data matrix
mean_frame_di_gauss = np.mean(data_matrix_di_gauss, axis=0)

frame_di_gauss = mean_frame_di_gauss.reshape(375, 705)

plt.imshow(frame_di_gauss)
plt.axis('off')
plt.show()

# Subtract the mean from each frame
data_matrix_centered_di_gauss = data_matrix_di_gauss - mean_frame_di_gauss

normalized_data_matrix_di_gauss = data_matrix_centered_di_gauss / np.linalg.norm(data_matrix_centered_di_gauss)

# Apply rSVD
k = 30  # Number of singular vectors and values to retain
U_di_gauss, Sigma_di_gauss, VT_di_gauss = np.linalg.svd(normalized_data_matrix_di_gauss, full_matrices=False)
Ur_di_gauss = U_di_gauss[:, :k]
Sigmak_di_gauss = np.diag(Sigma_di_gauss[:k])
VTr_di_gauss = VT_di_gauss[:k, :]

pod_modes_svd_di_gauss = VTr_di_gauss[:k, :].T

print(U_di_gauss.shape)
print(Sigma_di_gauss.shape)
print(VT_di_gauss.shape)
print(pod_modes_svd_di_gauss.shape)

print(Ur_di_gauss.shape)
print(Sigmak_di_gauss.shape)
print(VTr_di_gauss.shape)
print(pod_modes_svd_di_gauss.shape)

Sigmak_diag_di_gauss = np.diag(Sigmak_di_gauss)

# Compute the energy content of each mode
energy_content_di_gauss = Sigmak_diag_di_gauss**2

# Total energy captured by all modes
total_energy_di_gauss = np.sum(energy_content_di_gauss)

# Normalize energy content
normalized_energy_content_di_gauss = energy_content_di_gauss / total_energy_di_gauss


# Assuming energy_content contains the energy content of each mode
top_10_modes_indices_di_gauss = np.argsort(energy_content_di_gauss)[::-1][:10]

# Print energy of the top 10 modes
print("Energy of the top 10 modes:")
for mode_index in top_10_modes_indices_di_gauss:
    print(f"Mode {mode_index + 1}: Energy = {normalized_energy_content_di_gauss[mode_index]}")

# Plot histogram of energy content vs mode
plt.figure(figsize=(12, 6))
plt.bar(range(1, len(normalized_energy_content_di_gauss) + 1), normalized_energy_content_di_gauss, color='skyblue', edgecolor='black')
plt.title('Energy vs Mode')
plt.xlabel('Mode')
plt.ylabel('Energy')
plt.grid(axis='y')
plt.show()

largest_energy_mode_index_di_gauss = np.argmax(energy_content_di_gauss)
largest_energy_mode_di_gauss = Ur_di_gauss[:, largest_energy_mode_index_di_gauss]

# Print or use the largest energy mode as needed
print("Mode with the largest energy:")
print(largest_energy_mode_di_gauss)

pod_modes_svd_transpose_di_gauss = np.transpose(pod_modes_svd_di_gauss)

# Function to display POD mode as an image
def display_pod_mode(mode, index):
    # Reshape the mode to the shape of the original image
    mode_image = mode.reshape(375, 705)

    # Convert to 8-bit depth
    mode_image_8bit = cv2.normalize(mode_image, None, 0, 255, cv2.NORM_MINMAX, dtype=cv2.CV_8U)

    # Plot the mode
    plt.imshow(mode_image_8bit)
    plt.title(f'POD Mode {index+1}')
    plt.axis('off')
    plt.show()

# Display the POD modes as 8-bit depth images
for (i), mode in enumerate(pod_modes_svd_transpose_di_gauss):
    display_pod_mode(mode, i)
    if(i==5):
      break

"""### Salt & Pepper Noise on 20%"""

def denoise_frame(frame, prev_frame=None, median_kernel_size=3, gaussian_kernel_size=(5, 5), bilateral_diameter=7, bilateral_sigma_color=50, bilateral_sigma_space=50):

    # Apply Median Filtering
    denoised_frame = cv2.medianBlur(frame, median_kernel_size)

    # Apply Gaussian Filtering
    denoised_frame = cv2.GaussianBlur(denoised_frame, gaussian_kernel_size, 0)

    # Apply Bilateral Filtering
    denoised_frame = cv2.bilateralFilter(denoised_frame, bilateral_diameter, bilateral_sigma_color, bilateral_sigma_space)

    # Apply Temporal Filtering
    if prev_frame is not None:
        # Perform temporal averaging
        denoised_frame = cv2.addWeighted(denoised_frame, 0.5, prev_frame, 0.5, 0)
        # Update previous frame for next iteration
        updated_prev_frame = frame.copy()
    else:
        updated_prev_frame = frame.copy()

    return denoised_frame, updated_prev_frame



denoised_frames_sp = []
updated_prev_frame_sp = None
for frame in noisy_frames_salt_pepper_20:
    denoised_frame_sp, updated_prev_frame_sp = denoise_frame(frame, prev_frame=updated_prev_frame_sp)
    denoised_frames_sp.append(denoised_frame_sp)

plt.figure(figsize=(10, 10))

# Original frame
plt.subplot(2, 1, 1)
plt.imshow(denoised_frames_sp[100])
plt.title('Noisy Frame (Salt & Pepper) denoised')
plt.axis('off')

# Noisy frame with Gaussian noise
plt.subplot(2, 1, 2)
plt.imshow(noisy_frames_salt_pepper_20[100])
plt.title('Noisy Frame (Salt & Pepper)')
plt.axis('off')

psnr_values_sp = []
ssim_values_sp = []

def evaluate_frame(original_frame, denoised_frame):
    # Calculate PSNR
    psnr_value = psnr(original_frame, denoised_frame)
    # Calculate SSIM
    ssim_value = ssim(original_frame, denoised_frame)
    return psnr_value, ssim_value

for original_frame, denoised_frame in zip(frames_df['Frame_data'], denoised_frames_sp):
    # Calculate PSNR and SSIM for the current frame pair
    psnr_value, ssim_value = evaluate_frame(original_frame, denoised_frame)

    # Append PSNR and SSIM values to the lists
    psnr_values_sp.append(psnr_value)
    ssim_values_sp.append(ssim_value)

average_psnr_sp = sum(psnr_values_sp) / len(psnr_values_sp)
average_ssim_sp = sum(ssim_values_sp) / len(ssim_values_sp)

print("Average PSNR:", average_psnr_sp)
print("Average SSIM:", average_ssim_sp)

"""#### Applying SVD"""

flattened_frames_di_sp = [frame.flatten() for frame in denoised_frames_sp]

# Stack flattened frames into a matrix
data_matrix_di_sp = np.stack(flattened_frames_di_sp, axis=0)

# Compute the mean of the data matrix
mean_frame_di_sp = np.mean(data_matrix_di_sp, axis=0)

frame_di_sp = mean_frame_di_sp.reshape(375, 705)

plt.imshow(frame_di_sp)
plt.axis('off')
plt.show()

# Subtract the mean from each frame
data_matrix_centered_di_sp = data_matrix_di_sp - mean_frame_di_sp

normalized_data_matrix_di_sp = data_matrix_centered_di_sp / np.linalg.norm(data_matrix_centered_di_sp)

# Apply rSVD
k = 30  # Number of singular vectors and values to retain
U_di_sp, Sigma_di_sp, VT_di_sp = np.linalg.svd(normalized_data_matrix_di_sp, full_matrices=False)
Ur_di_sp = U_di_sp[:, :k]
Sigmak_di_sp = np.diag(Sigma_di_sp[:k])
VTr_di_sp = VT_di_sp[:k, :]

pod_modes_svd_di_sp = VTr_di_sp[:k, :].T

print(U_di_sp.shape)
print(Sigma_di_sp.shape)
print(VT_di_sp.shape)
print(pod_modes_svd_di_sp.shape)

print(Ur_di_sp.shape)
print(Sigmak_di_sp.shape)
print(VTr_di_sp.shape)
print(pod_modes_svd_di_sp.shape)

Sigmak_diag_di_sp = np.diag(Sigmak_di_sp)

# Compute the energy content of each mode
energy_content_di_sp = Sigmak_diag_di_sp**2

# Total energy captured by all modes
total_energy_di_sp = np.sum(energy_content_di_sp)

# Normalize energy content
normalized_energy_content_di_sp = energy_content_di_sp / total_energy_di_sp

# Assuming energy_content contains the energy content of each mode
top_10_modes_indices_di_sp = np.argsort(energy_content_di_sp)[::-1][:10]

# Print energy of the top 10 modes
print("Energy of the top 10 modes:")
for mode_index in top_10_modes_indices_di_sp:
    print(f"Mode {mode_index + 1}: Energy = {normalized_energy_content_di_sp[mode_index]}")

# Plot histogram of energy content vs mode
plt.figure(figsize=(12, 6))
plt.bar(range(1, len(normalized_energy_content_di_sp) + 1), normalized_energy_content_di_sp, color='skyblue', edgecolor='black')
plt.title('Energy vs Mode')
plt.xlabel('Mode')
plt.ylabel('Energy')
plt.grid(axis='y')
plt.show()

largest_energy_mode_index_di_sp = np.argmax(energy_content_di_sp)
largest_energy_mode_di_sp = Ur_di_sp[:, largest_energy_mode_index_di_sp]

# Print or use the largest energy mode as needed
print("Mode with the largest energy:")
print(largest_energy_mode_di_sp)

pod_modes_svd_transpose_di_sp = np.transpose(pod_modes_svd_di_sp)

# Function to display POD mode as an image
def display_pod_mode(mode, index):
    # Reshape the mode to the shape of the original image
    mode_image = mode.reshape(375, 705)

    # Convert to 8-bit depth
    mode_image_8bit = cv2.normalize(mode_image, None, 0, 255, cv2.NORM_MINMAX, dtype=cv2.CV_8U)

    # Plot the mode
    plt.imshow(mode_image_8bit)
    plt.title(f'POD Mode {index+1}')
    plt.axis('off')
    plt.show()

# Display the POD modes as 8-bit depth images
for (i), mode in enumerate(pod_modes_svd_transpose_di_sp):
    display_pod_mode(mode, i)
    if(i==5):
      break